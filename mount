#!/bin/sh 

set -e

. /usr/share/live-guest/functions
source_parts /etc/live-guest.d

mkdir_if_not() {
  [ -d $1 ] || mkdir -p $1
}

cleanup_and_exit() {

  log notice "Cleaning up and unmounting partitions."

  [ -z "$1" ] && exitcode=$1 || exitcode=1

  remove_user

  for mp in ${MOUNTPOINTS} ; do
    umount_and_remove $mp
  done
  rm ${LOCKFILE} && true
  
  # remove trap on exit to avoid rerunning it
  trap '' 0

  log notice "Done cleaning up."
  exit $exitcode
}

start_log

log notice "Checking disk ${DEVNAME} for Debian Live system."

# Check if a user session is running, exit if someone is logged in
if ck-list-sessions | grep -q Session ; then
    log notice "A user session is running, exiting."
    exit 0
fi

# Double check if we really have a disk, only disks
# should trigger the udev rule.
if [ "$DEVTYPE" != "disk" ] ; then
    log warn "Not a disk, exiting."
    exit 0
fi

# check lock file
if [ -f ${LOCKFILE} ] ; then
  LOCKDEV=$(cat ${LOCKFILE})

  # exit if our device is not the locked device and the locked
  # device still exists
  if [ "${LOCKDEV}" != "${DEVNAME}" -a -b ${LOCKDEV} ] ; then
      log notice "Another Debian Live guest system is already mounted."
      exit 0
  fi
fi

# unmount and remove lockfile if something fails
trap cleanup_and_exit 0 INT TERM

# Lock the device
echo ${DEVNAME} > ${LOCKFILE}

# give the device some time to settle
sleep 1

roopt="rr"
rofsstring=""
PARTITIONS=$(ls $DEVNAME?)
MOUNTPOINTS=""
for p in ${PARTITIONS} ; do
  log debug "Checking partition: ${p}."

  # check if the partition is already mounted
  grep -q ${p} /proc/mounts && log debug "Partition ${p} already mounted." && continue
 
  # check for COW partition
  LABEL=$(blkid -o value -s LABEL ${p} || true) # blkid sometimes just fails, try to continue without label
  log debug "Partition $p, Label: $LABEL"
  if [ -z "${COWDEV}" -a "$LABEL" = "live-rw" ] ; then
     mkdir_if_not ${MOUNT_COW_DIR}
     mount ${p} ${MOUNT_COW_DIR}
     MOUNTPOINTS="${MOUNT_COW_DIR} ${MOUNTPOINTS}"
     COWDEV=${p}
     log notice "Mounted COW partition ${p} on ${COW_MOUNT_DIR}"
     continue
  fi

  # try to mount volume
  MOUNT_DIR="${MOUNT_PARTITIONS_DIR}/$(basename ${p})"
  mkdir_if_not ${MOUNT_DIR}
  mount ${p} ${MOUNT_DIR}
  MOUNTPOINTS="${MOUNT_DIR} ${MOUNTPOINTS}"
  log notice "Mounted partition ${p} on ${MOUNT_DIR}, now scanning for live filesystems."
  
  # check for live directory
  image_string=""
  if [ -d ${MOUNT_DIR}/live ] ; then
    # scan for filesystem images
    for FILESYSTEM in squashfs ext2 ext3 ext4 xfs jffs2 ; do
      for IMAGE in "${MOUNT_DIR}/live"/*."${FILESYSTEM}" ; do
        if [ -e "${IMAGE}" ] ; then
          image_string="${image_string} ${IMAGE}"
        fi
      done
    done

    if [ -n "${image_string}" ] ; then
      # mount filesystem images
      for image in ${image_string} ; do
        imagename=$(basename "${image}")
        MOUNT_IMAGE_DIR="${MOUNT_BASE_DIR}/${imagename}"
        mkdir_if_not ${MOUNT_IMAGE_DIR}
        mount -o loop,ro,noatime ${image} ${MOUNT_IMAGE_DIR}
        MOUNTPOINTS="${MOUNT_IMAGE_DIR} ${MOUNTPOINTS}"
        log notice "Mounted live filesystem image ${image} on ${MOUNT_IMAGE_DIR}."
        rofsstring="${MOUNT_IMAGE_DIR}=${roopt}:${rofsstring}"
      done
      continue
    fi
  fi

  # nothing interesting here, unmount
  umount ${p} && rmdir ${MOUNT_DIR}
  MOUNTPOINTS=$(for m in ${MOUNTPOINTS} ; do [ "$m" != "${MOUNT_DIR}" ] && echo $m ; done) || true
  log notice "Unmounting partition ${p}. No live filesystems or COW partitions found."

done

# check if we found a COW and a root partition
if [ -z "${COWDEV}" ] ; then
  log notice "No COW partition found. Exiting."
  cleanup_and_exit 0
elif [ -z "${rofsstring}" ] ; then
  log notice "No Debian live filesystem images fond. Exiting."
  cleanup_and_exit 0
fi

# create root mount point
mkdir_if_not ${MOUNT_ROOT_DIR}

# Assemble aufs stacked filesystem
mount -t ${UNIONTYPE} -o noatime,noxino,dirs=${MOUNT_COW_DIR}=rw:${rofsstring%:} ${UNIONTYPE} "${MOUNT_ROOT_DIR}"
MOUNTPOINTS="${MOUNT_ROOT_DIR} ${MOUNTPOINTS}"
log notice "Assembled Debian Live union filesystem on ${MOUNT_ROOT_DIR}"

# create guest user if it does not yet exist
getent passwd ${USER} > /dev/null || adduser --gecos "Guest Live user" --no-create-home --disabled-login ${USER} && log debug "Created Guest Live user."

# Add user the default groups, get groups from debconf database
groups=$(echo "GET passwd/user-default-groups" | debconf-communicate | cut -c3- | tr " " ",")
log debug "Adding ${USER} user to groups $groups."
usermod "$USER" -a -G "$groups"

# create and chown home directory
log debug "Creating home directory for ${USER} user."
[ -d /home/${USER} ] || mkdir /home/${USER}
chown ${USER}:${USER} /home/${USER}

# copy password from guest stick
log debug "Copying password."
PW=$(egrep ^user: ${MOUNT_ROOT_DIR}/etc/shadow | cut -f 2 -d :)
usermod --password="$PW" ${USER}

# copy gecos from guest stick
log debug "Copying GECOS."
GECOS=$(egrep ^user: ${MOUNT_ROOT_DIR}/etc/passwd | cut -f 5 -d : | cut -f 1 -d ,)
chfn -f "${GECOS}" ${USER}

# bind mount to home directory
log debug "Mounting home directory with bindfs."
bindfs -o nonempty --map=user/${USER}:@user/@${USER} ${MOUNT_ROOT_DIR}/home/user /home/${USER}
MOUNTPOINTS="/home/${USER} ${MOUNTPOINTS}"

# run custom scripts
log info "Running custom scripts."
for dir in /usr/share/live-guest/mount.d /usr/local/share/live-guest/mount.d ; do
    [ -d ${dir} ] && run-parts --arg="mount" ${dir} 2>&1 | logger -t live-guest -p user.notice
done

# kill display manager greeter to show the new user
log debug "Restarting display managers."
notify_dm

# this logs in the live-guest user if the password was not changed from
# the default debian-live pw
if [ "${PW}" = "${LIVE_GUEST_PW_CRYPT}" ] ; then
    log notice "Trying to log in the live-guest user."
    kdmctl login :0 now live-guest ${LIVE_GUEST_PW} || true
fi

trap '' 0 INT TERM

log notice "Finished mounting guest Debian Live system."