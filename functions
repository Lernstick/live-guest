notify_dm() {
  pkill -HUP gdmgreeter || true
  /etc/init.d/kdm restart || true
}

log() {
  logger -t live-guest -p user.${1} ${2}
}

cleanup_and_exit() {
  for mp in ${MOUNTPOINTS} ; do
    umount $mp && rmdir $mp && true
    log debug "Unmounting $mp."
  done
  rm ${LOCKFILE} && true
  exit $1
}

source_parts() {
  [ -d $1 ] || return
  conffiles=$(echo $1/*.conf | sort)
  for f in $conffiles ; do
    . $f
  done
}

start_log() {
  if [ -n "${DEBUG_LOG_FILE}" ] ; then
    echo "======== $0 on $(date) ==========" >> ${DEBUG_LOG_FILE}
    exec >> ${DEBUG_LOG_FILE} 2>&1
    set -x
  fi 
}

umount_and_remove() {

  # kill all processes still accessing the mount point
  signal="TERM"
  while [ -n "$(fuser -M -m $1)" ]; do
    # fuser has strange return values. This means there are still processes
    # relying on the return value did not work (it changes wheter -s is given or not)
    log notice "Some processes still accessing $1. Trying to kill them with SIG${signal}."
    fuser -M -m $1 -k -$signal || true
    sleep 5
    [ ${signal} = "KILL" ] && break
    signal="KILL"
  done
  procs=$(fuser -M -m $1 || true)
  [ -n "${procs}" ] && log warn "Not all processes accessing $1 where terminated: $procs. Continueing anyway."

  # try to unmount device for 15s (some processes need some time to properly quit)
  i=0
  log notice "Trying to unmount $1"
  while ! umount ${UNMOUNT_OPTS} $1 ; do
    if [ $i -gt ${UNMOUNT_TIMEOUT} ] ; then
      log warn "Unmounting $1 failed, stopped retrying after ${UNMOUNT_TIMEOUT} seconds."
      if mount -o ro,remount $1 ; then
        log notice "Remounted $1 in read-only mode."
      else
        log warn "Failed to remount $1 in read-only mode. Completely failed to unmount device."
      fi
      break
    fi
    log debug "Unmounting $1 failed, retrying in ${UNMOUNT_INTERVAL} seconds."
    sleep ${UNMOUNT_INTERVAL}
    i=$((i+${UNMOUNT_INTERVAL}))
  done

  rmdir $1 || true
  log notice "Finished unmounting $1."
}

